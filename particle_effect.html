<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Antigravity Particle Effect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            /* White background like the screenshot */
            font-family: 'Google Sans', sans-serif;
        }

        canvas {
            display: block;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            /* Let clicks pass through to canvas if needed */
            color: #202124;
        }

        h1 {
            font-size: 4rem;
            margin: 0;
            letter-spacing: -0.02em;
        }

        p {
            font-size: 1.5rem;
            color: #5f6368;
        }
    </style>
</head>

<body>

    <div id="overlay">
        <h1>Experience liftoff</h1>
        <p>with the next-generation IDE</p>
    </div>

    <!-- Import Three.js from CDN -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); // White background
        scene.fog = new THREE.FogExp2(0xffffff, 0.002); // Soft fog for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30; // Closer camera for the vortex effect
        camera.position.y = 0;  // Centered

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- Particle System Configuration ---
        const PARTICLE_COUNT = 4000; // More particles for the vortex

        // Geometry
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const originalPositions = [];
        const randomOffsets = [];
        const speeds = [];

        // Create particles in a Vortex / Gravity Well shape
        // Formula: z = -1 / r (roughly)

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // Random radius with more particles in the center (logarithmic-ish distribution)
            // We want r from roughly 1 to 40
            const r = Math.random() * 40 + 1;

            // Spiral angle
            const theta = Math.random() * Math.PI * 2;

            // Vortex depth calculation (The "Antigravity" funnel)
            // The closer to center (r=0), the deeper (negative Z)
            // We use a power function to shape the curve nicely
            const depth = -150 / (r + 2);

            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            // Orient so the "hole" faces the camera (Z axis)
            // x, y are screen coordinates, z is depth.

            const px = x;
            const py = y;
            const pz = depth;

            positions.push(px, py, pz);
            originalPositions.push(px, py, pz);
            randomOffsets.push(Math.random() * Math.PI * 2);
            speeds.push(0.2 + Math.random() * 0.5); // Swirl speed
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('originalPosition', new THREE.Float32BufferAttribute(originalPositions, 3));
        geometry.setAttribute('randomOffset', new THREE.Float32BufferAttribute(randomOffsets, 1));
        geometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));

        // Material
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext('2d');
        context.beginPath();
        context.arc(16, 16, 14, 0, Math.PI * 2);
        context.fillStyle = '#ffffff';
        context.fill();
        const texture = new THREE.CanvasTexture(canvas);

        const material = new THREE.PointsMaterial({
            color: 0x4285F4, // Google Blue
            size: 0.3,
            map: texture,
            transparent: true,
            opacity: 0.8,
            alphaTest: 0.01,
            sizeAttenuation: true,
            blending: THREE.MultiplyBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Mouse Interaction ---
        const mouse = new THREE.Vector2();
        const targetRotation = new THREE.Vector2();
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX - windowHalfX) / 100;
            mouse.y = (event.clientY - windowHalfY) / 100;
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const positions = particles.geometry.attributes.position.array;
            const originals = particles.geometry.attributes.originalPosition.array;
            const offsets = particles.geometry.attributes.randomOffset.array;
            const speeds = particles.geometry.attributes.speed.array;

            // "Medusa" Breathing + Vortex Swirl
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                const ox = originals[i3];
                const oy = originals[i3 + 1];
                const oz = originals[i3 + 2]; // This is the depth

                // 1. Breathing (Expansion/Contraction)
                // We pulse the radius based on time
                const pulse = Math.sin(time * 1.5 + oz * 0.1) * 0.1 + 1; // Wave travels along depth

                // 2. Swirl (Rotation around Z axis)
                // Particles closer to center (deeper) rotate faster? Or uniform?
                // Let's do a uniform swirl for the "Medusa" feel
                const swirlAngle = time * speeds[i] * 0.5;
                const cosA = Math.cos(swirlAngle);
                const sinA = Math.sin(swirlAngle);

                // Rotate ox, oy
                let rx = ox * cosA - oy * sinA;
                let ry = ox * sinA + oy * cosA;

                // Apply breathing scale
                rx *= pulse;
                ry *= pulse;
                // We also breathe the depth slightly to make the funnel open/close
                const rz = oz * (1 + Math.sin(time * 1.5) * 0.1);

                positions[i3] = rx;
                positions[i3 + 1] = ry;
                positions[i3 + 2] = rz;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 3. Mouse Interaction (Tilt the whole vortex)
            // We tilt the container based on mouse position to look "into" the hole from different angles
            targetRotation.x = mouse.y * 0.5; // Tilt up/down
            targetRotation.y = mouse.x * 0.5; // Tilt left/right

            particles.rotation.x += (targetRotation.x - particles.rotation.x) * 0.05;
            particles.rotation.y += (targetRotation.y - particles.rotation.y) * 0.05;

            renderer.render(scene, camera);
        }

        animate();

        // --- Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>